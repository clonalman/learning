一、遍历
----------------------------------------------------------------------------------
g.V().has('name', hercules').out('father').out('father').values('name')

1. g：当前图的遍历句柄。
2. V：图中所有的顶点。
3. has('name', 'hercules')：过滤出顶点name为hercules的顶点。
4. out('father')：从hercules顶点遍历出边为father的边。
5. out('father')：从hercules的father顶点遍历出边为father的边。
6. name：获取hercules祖父顶点的name属性的值。
----------------------------------------------------------------------------------
g.V().has('name', 'hercules').repeat(out('father')).emit().values('name')

循环操作：
repeat(): 指定要重复执行的语句，如repeat(out('friend'))
times(): 指定要重复执行的次数，如执行3次repeat(out('friend')).times(3)
until(): 指定循环终止的条件，如一直找到某个名字的朋友为止repeat(out('friend')).until(has('name','xiaofang'))
emit(): 指定循环语句的执行过程中收集数据的条件，每一步的结果只要符合条件则被收集，不指定条件时收集所有结果
loops(): 当前循环的次数，可用于控制最大循环次数等，如最多执行3次repeat(out('friend')).until(loops().is(3))

----------------------------------------------------------------------------------
g.V(hercules).as('h').out('battled').in('battled').where(neq('h')).values('name')

4个链接函数：
1. out: V -> V
2. in: V -> V
3. except: U -> U
4. values: V -> U
----------------------------------------------------------------------------------

二、遍历迭代

iterate() - 预期或者可以忽略空值。
next() - 获取一个结果，一定要先通过hasNext()判断。
next(int n) - 获取第n个结果，一定要先通过hasNext()判断。
toList() - 获取所有的结果作为一个list，如果没有结果则返回空列表。

例子：
Traversal t = g.V().has("name", "pluto"); // Define a traversal
// Note the traversal is not executed/iterated yet
Vertex pluto = null;
if (t.hasNext()) { // Check if results are available
    pluto = g.V().has("name", "pluto").next(); // Get one result
    g.V(pluto).drop().iterate(); // Execute a traversal to drop pluto from graph
}
// Note the traversal can be cloned for reuse
Traversal tt = t.asAdmin().clone();
if (tt.hasNext()) {
    System.err.println("pluto was not dropped!");
}
List<Vertex> gods = g.V().hasLabel("god").toList(); // Find all the gods

三、路径(path、simplePath、cyclicPath)

// “HugeGraph”顶点到与其有直接关联的顶点的路径（仅包含顶点）
g.V().hasLabel('software').has('name','HugeGraph').both().path()

// “HugeGraph”顶点到与其有直接关联的顶点的路径（包含顶点和边）
g.V().hasLabel('software').has('name','HugeGraph')
 .bothE().otherV().path()

// “HugeGraph”顶点到与其有直接关联的顶点的路径（包含顶点和边）
// 用“name”属性代表person和software顶点，用“weight”属性代表边
g.V().hasLabel('software').has('name','HugeGraph')
 .bothE().otherV().path().by('name').by('weight')

// “HugeGraph”顶点到与其有两层关系的顶点的不含环路的路径（只包含顶点）
g.V().hasLabel('software').has('name','HugeGraph')
 .both().both().simplePath().path()

// “HugeGraph”顶点到与其有两层关系的顶点的包含环路的路径（只包含顶点）
g.V().hasLabel('software').has('name','HugeGraph')
 .both().both().cyclicPath().path()

四、更多例子：

查找子树：

// 查找从一个节点出发，到
// 叶子节点结束的所有路径
// 这些路径的集合为一颗子树(子图)
g.V('okram')
 .repeat(out())
 .until(outE().count().is(0))
 .path()


查找两点之间的最短路径：
// 已知两个顶点'okram'和'javeme'，
// 通过任意关系来找到这两点之间的路径
// 且限制了最大深度为3
// 若存在那么第一条结果即是最短路径
g.V('okram')
 .repeat(bothE().otherV().simplePath())
 .until(hasId('javeme').and().loops().is(lte(3)))
 .hasId('javeme')
 .path()